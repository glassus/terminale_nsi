# Épreuve Pratique BNS 2026

Vous pouvez retrouver ici les 3 sujets 0 publiés le 08/10/2025.

!!! example "Sujet 1"
    - [Sujet](data/EP_sujets0_1/EP-BAC-NSI-Sujet1.pdf){. target="_blank"}
    - [cycle_menstruel.py](data/EP_sujets0_1/cycle_menstruel.py){. target="_blank"}

    {{
    correction(False,
    """
    ??? success \"Correction **Q1**\" 
        ```python
        def est_bissextile(n):
            if n % 400 == 0:
                return True
            elif n % 4 == 0 and n % 100 != 0:
                return True
            else:
                return False
        ```
    """
    )
    }}

    {{
    correction(False,
    """
    ??? success \"Correction **Q2**\" 
        ```python
        def determiner_phase(n):
            assert n <= 28 and n >= 1
            if n <= 5:
                return 1
            elif n <= 13:
                return 2
            elif n == 14:
                return 3
            else:
                return 4
        ```
    """
    )
    }}

    {{
    correction(False,
    """
    ??? success \"Correction **Q3**\" 
        ```python
        def test_ajouter_jours():
            assert ajouter_jours((7, 9, 2025), 3) == (10, 9, 2025)

            assert ajouter_jours((29, 8, 2025), 3) == (1, 9, 2025)
            #pour tester le changement de mois sur un mois à 31 jours

            assert ajouter_jours((29, 9, 2025), 3) == (2, 10, 2025)
            #pour tester le changement de mois sur un mois à 30 jours

            assert ajouter_jours((31, 12, 2025), 1) == (1, 1, 2026)
            #pour tester un changement d'année

            assert ajouter_jours((28, 2, 2024), 3) == (2, 3, 2024)
            #pour tester le changement de mois sur une année bissextile

            assert ajouter_jours((28, 2, 2025), 3) == (3, 3, 2025)
            #pour tester le changement de mois sur une année non-bissextile
        ```
    """
    )
    }}


    {{
    correction(False,
    """
    ??? success \"Correction **Q4**\" 
        L'erreur qui apparait 
        ```python
         datetime(
        ValueError: month must be in 1..12
        ``` 
        semble nous indiquer que la date n'est pas au bon format.
        
        En effet la documentation de ```iCalendar``` nous dit que la date doit être écrite au format ```AAAAMMJJ```.

        Or, la ligne de code
        ```python
        date = str(annee)+str(mois) +str(jour)
        ``` 
        va produire 202535 pour le 05 mars 2025, au lieu de 20250305.

        Pour résoudre ce problème, il faut remplacer cette ligne par :
        ```python
        date = str(annee)+'{:02d}'.format(mois) + '{:02d}'.format(jour)
        ```

        *Remarque : le formatage des chaînes de caractères n'est pas au programme...*


    """
    )
    }}


!!! example "Sujet 2"
    - [Sujet](data/EP_sujets0_2/EP-BAC-NSI-Sujet2.pdf){. target="_blank"}
    - [analyse.py](data/EP_sujets0_2/analyse.py){. target="_blank"}
    - [donnees.py](data/EP_sujets0_2/donnees.py){. target="_blank"}
    - [donnees_completes.py](data/EP_sujets0_2/donnees_completes.py){. target="_blank"}

    {{
    correction(False,
    """
    ??? success \"Correction **Q1**\" 
        ```python
        def salaire_moyen_condition(employes, champ, valeur):
            '''Renvoie le salaire moyen des employes ayant val comme valeur associée
            au champ donné en argument.
            Si le nombre d'employés considéré est nul, cette fonction renvoie None'''
            s = 0
            n = 0
            for employe in employes:
                if employe[champ] == valeur:
                    s += employe['salaire']
                    n += 1
            if s == 0:
                return None
            return s/n
        ```
    """
    )
    }}

    {{
    correction(False,
    """
    ??? success \"Correction **Q2**\" 
        ```python
        def effectif_par_sexe(employes):
            nf, nh = 0, 0
            for employe in employes:
                if employe['sexe'] == 'F':
                    nf += 1
                else:
                    nh += 1
            return {'F':nf, 'M':nh}
        ```
    """
    )
    }}

    {{
    correction(False,
    """
    ??? success \"Correction **Q3**\" 
        - Le calcul de ```moy_f``` va renvoyer une erreur car ```employes``` est mis entre guillements.
        - De plus, le calcul final est faux puisqu'il fait simplement la différence entre ```moy_h``` et ```moy_f```.

        ```python
        def calcul_ecart_sexe(employes):
            '''Renvoie l'écart de salaire en pourcentage pour les femmes 
            par rapport aux hommes'''
            if effectif_par_sexe(employes)['F'] == 0 or effectif_par_sexe(employes)['M'] == 0:
                return None
            moy_h = salaire_moyen_condition(employes, 'sexe', 'M')
            moy_f = salaire_moyen_condition(employes, 'sexe', 'F')
            return (moy_h - moy_f) / moy_h * 100

        def test_calcul_ecart_sexe():
            assert calcul_ecart_sexe([{'experience': 5, 'etudes': 3, 'sexe': 'F', 'salaire': 2400}]) == None
            assert calcul_ecart_sexe(donnees.employes) >= 0 and calcul_ecart_sexe(donnees.employes) <= 100


        ```
    """
    )
    }}


    {{
    correction(False,
    """
    ??? success \"Correction **Q4**\" 
        ```python
        >>> salaire_par_proximite(donnees_completes.employes, {'experience': 3, 'etudes': 3, 'sexe': 'F'})
        2229.6666666666665
        >>> salaire_par_proximite(donnees_completes.employes, {'experience': 3, 'etudes': 3, 'sexe': 'M'})
        2406.0
        ``` 
        Il y a un problème dans le code dans le calcul de la distance. En effet, si deux personnes sont de sexe différent, leur distance sera augmentée de 4 par rapport à si elles étaient de même sexe. Ceci n'a pas de raison d'être alors qu'on cherche justement à mesurer les écarts selon le sexe.

        Une bonne fonction ```distance```  serait donc :
        ```python
        def distance(e1, e2):
            '''Renvoie la mesure de distance entre deux personnes.'''
            s = 0
            s = s + (e1['experience'] - e2['experience'])**2
            s = s + (e1['etudes'] - e2['etudes'])**2
            return sqrt(s)
        ```

        

    """
    )
    }}



!!! example "Sujet 3"
    - [Sujet](data/EP_sujets0_3/EP-BAC-NSI-Sujet3.pdf){. target="_blank"}
    - [rle.py](data/EP_sujets0_3/rle.py){. target="_blank"}
    - [bac_nsi_32.png](data/EP_sujets0_3/bac_nsi_32.png){. target="_blank"}
    - [bac_nsi_256.png](data/EP_sujets0_3/bac_nsi_256.png){. target="_blank"}
    

    {{
    correction(False,
    """
    ??? success \"Correction **Q1**\" 
        Si la liste originale est ```[3, 5, 0, 6]```, la liste obtenue par codage RLE est ```[1, 3, 1, 5, 1, 0, 1, 6]```, qui est 2 fois plus longue. Donc non, la liste obtenue par codage RLE n'est pas forcément de longueur inférieure ou égale.  
    """
    )
    }}

    {{
    correction(False,
    """
    ??? success \"Correction **Q2**\" 
        ```python
        def decodage_rle(liste_rle):
            '''Renvoie la liste d'octets obtenue à partir de la liste liste_rle obtenue
            par compression RLE'''
            lst = []
            for i in range(0, len(liste_rle), 2):
                for k in range(liste_rle[i]):
                    lst.append(liste_rle[i+1])
            return lst
        ```
    """
    )
    }}

    {{
    correction(False,
    """
    ??? success \"Correction **Q3**\" 
        On constate que, si tout se passe bien pour l'image ```bac_nsi_32.png```, l'image ```bac_nsi_256.png.dec.png``` obtenue après encodage/décodage de l'image ```bac_nsi_256.png``` présente un décalage de l'écriture.
    """
    )
    }}


    {{
    correction(False,
    """
    ??? success \"Correction **Q4**\" 
        Il faut modiier la fonction ```codage_rle``` pour faire en sorte qu'elle prenne en compte les valeurs dont le nombre dépasse 255. Il suffit de faire plusieurs «paquets» de 255 de cette valeur.
        ```python
        def codage_rle(liste_octets):
            '''Renvoie une liste d'octets obtenue par compression RLE'''
            liste_rle = []
            i = 0
            while i < len(liste_octets):
                c = liste_octets[i]
                k = 1
                while i+k < len(liste_octets) and liste_octets[i+k] == c:
                    k += 1
                q = k // 255
                r = k % 255
                for _ in range(q):
                    liste_rle.append(255)
                    liste_rle.append(c)
                if r != 0:
                    liste_rle.append(r)
                    liste_rle.append(c)
                i += k
            return liste_rle
        ```




    """
    )
    }}
